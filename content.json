[{"title":"leetcode_449_序列化和反序列化二叉搜索树","date":"2019-09-02T13:21:33.000Z","path":"2019/09/02/2019-09-02-21-21/","text":"题目描述：设计一个算法来序列化和反序列化二叉搜索树。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。 编码的字符串应尽可能紧凑。注意：不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。 思路：根据二叉搜索树的前序遍历序列，可以唯一确定一颗二叉搜索树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Codec &#123; public String serialize(TreeNode root)&#123; StringBuffer buffer = new StringBuffer(); preOrder(root,buffer); return buffer.toString(); &#125; public void preOrder(TreeNode node,StringBuffer buffer)&#123; if(node == null)&#123; return; &#125; buffer.append(node.val).append(&quot;#&quot;); preOrder(node.left,buffer); preOrder(node.right,buffer); &#125; public TreeNode deserialize(String data)&#123; if(data.length() == 0)&#123; return null; &#125; int i = 0; int num = 0; while(data.charAt(i) != &apos;#&apos;)&#123; num = num * 10 + data.charAt(i) - &apos;0&apos;; i ++; &#125; TreeNode root = new TreeNode(num); num = 0; i ++; for(;i &lt; data.length();i ++)&#123; if(data.charAt(i) != &apos;#&apos;)&#123; num = num * 10 + data.charAt(i) - &apos;0&apos;; &#125;else&#123; TreeNode insert_node = new TreeNode(num); BST_insert(root,insert_node); num = 0; &#125; &#125; return root; &#125; public void BST_insert(TreeNode node,TreeNode insert_node)&#123; if(insert_node.val &lt; node.val)&#123; if(node.left == null)&#123; node.left = insert_node; &#125;else&#123; BST_insert(node.left,insert_node); &#125; &#125;else&#123; if(node.right == null)&#123; node.right = insert_node; &#125;else&#123; BST_insert(node.right,insert_node); &#125; &#125; &#125;&#125; 执行用时 :11 ms, 在所有 Java 提交中击败了97.54%的用户内存消耗 :41.3 MB, 在所有 Java 提交中击败了72.90%的用户","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"leetcode_medium","slug":"leetcode-medium","permalink":"http://yoursite.com/tags/leetcode-medium/"}]},{"title":"leetcode_207_课程表","date":"2019-09-02T05:09:33.000Z","path":"2019/09/02/2019-09-02-13-09/","text":"题目描述：现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 示例：123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 思路：根据题目描述，把课程之间的关系构造成一张图，课程1依赖课程0，表示有一条从课程0指向课程1的边。这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，就判断为不可能完成所有课程。 深度优先搜索判断有向图中有没有环：123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public class Graph&#123; int label; List&lt;Graph&gt; neighbors; public Graph(int label)&#123; this.label = label; neighbors = new ArrayList&lt;&gt;(); &#125; &#125; public boolean canFinish(int numCourses,int[][] prerequisites)&#123; Graph[] graph = new Graph[numCourses]; int[] visit = new int[numCourses]; for(int i = 0;i &lt; numCourses;i ++)&#123; graph[i] = new Graph(i); &#125; for(int i = 0;i &lt; prerequisites.length;i ++)&#123; graph[prerequisites[i][1]].neighbors.add(graph[prerequisites[i][0]]); &#125; for(int i = 0;i &lt; numCourses;i ++)&#123; if(visit[i] == 0 &amp;&amp; !DFS_graph(graph[i],visit))&#123; return false; &#125; &#125; return true; &#125; public boolean DFS_graph(Graph graph_node,int[] visit)&#123; visit[graph_node.label] = 1; for(int i = 0;i &lt; graph_node.neighbors.size();i ++)&#123; if(visit[graph_node.neighbors.get(i).label] == 0 &amp;&amp; !DFS_graph(graph_node.neighbors.get(i),visit))&#123; return false; &#125;else if(visit[graph_node.neighbors.get(i).label] == 1)&#123; return false; &#125; &#125; visit[graph_node.label] = 2; return true; &#125; &#125; 执行用时 :6 ms, 在所有 Java 提交中击败了98.42%的用户内存消耗 :42.5 MB, 在所有 Java 提交中击败了83.39%的用户 广度优先搜索判断有向图中有没有环：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public class Graph&#123; int label; List&lt;Graph&gt; neighbors; public Graph(int label)&#123; this.label = label; neighbors = new ArrayList&lt;&gt;(); &#125; &#125; public boolean canFinish(int numCourses,int[][] prerequisites)&#123; Graph[] graph = new Graph[numCourses]; int[] degree = new int[numCourses]; Queue&lt;Graph&gt; queue = new LinkedList&lt;&gt;(); for(int i = 0;i &lt; numCourses;i ++)&#123; graph[i] = new Graph(i); &#125; for(int i = 0;i &lt; prerequisites.length;i ++)&#123; graph[prerequisites[i][1]].neighbors.add(graph[prerequisites[i][0]]); degree[prerequisites[i][0]] ++; &#125; for(int i = 0;i &lt; numCourses;i ++)&#123; if(degree[i] == 0)&#123; queue.offer(graph[i]); &#125; &#125; while(!queue.isEmpty())&#123; Graph Q_node = queue.peek(); queue.poll(); for(int i = 0;i &lt; Q_node.neighbors.size();i ++)&#123; degree[Q_node.neighbors.get(i).label] --; if(degree[Q_node.neighbors.get(i).label] == 0)&#123; queue.offer(graph[Q_node.neighbors.get(i).label]); &#125; &#125; &#125; for(int i = 0;i &lt; degree.length;i ++)&#123; if(degree[i] != 0)&#123; return false; &#125; &#125; return true; &#125; &#125; 执行用时 :10 ms, 在所有 Java 提交中击败了87.71%的用户内存消耗 :48.1 MB, 在所有 Java 提交中击败了45.68%的用户","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"leetcode_medium","slug":"leetcode-medium","permalink":"http://yoursite.com/tags/leetcode-medium/"}]},{"title":"leetcode_236_二叉树的最近公共祖先","date":"2019-09-01T14:06:04.000Z","path":"2019/09/01/2019-09-01-22-05/","text":"题目描述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例：12输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3 说明：所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。 思路：记录从根节点到两个指定节点的路径，返回最后出现的相同节点 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; //表示是否已经找到了节点 int finish = 0; public TreeNode lowestCommonAncestor(TreeNode root,TreeNode p,TreeNode q)&#123; TreeNode result = root; int i = 0; List&lt;TreeNode&gt; p_path = new ArrayList&lt;&gt;(); List&lt;TreeNode&gt; q_path = new ArrayList&lt;&gt;(); preOrder(root,p,p_path); finish = 0; preOrder(root,q,q_path); while(i &lt; p_path.size() &amp;&amp; i &lt; q_path.size())&#123; if(p_path.get(i) == q_path.get(i))&#123; result = p_path.get(i); &#125; i ++; &#125; return result; &#125; public void preOrder(TreeNode node,TreeNode search,List&lt;TreeNode&gt; path)&#123; if(node == null || finish == 1)&#123; return; &#125; path.add(node); if(node.val == search.val)&#123; finish = 1; &#125; preOrder(node.left,search,path); preOrder(node.right,search,path); //如果找到了,回溯的时候就不需要回到上一个状态了 if(finish == 0)&#123; path.remove(path.size() - 1); &#125; &#125;&#125; 执行用时 :22 ms, 在所有 Java 提交中击败了17.56%的用户内存消耗 :38.8 MB, 在所有 Java 提交中击败了9.53%的用户","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"leetcode_medium","slug":"leetcode-medium","permalink":"http://yoursite.com/tags/leetcode-medium/"}]},{"title":"leetcode_165_比较版本号","date":"2019-08-31T13:19:49.000Z","path":"2019/08/31/2019-08-31_21_19/","text":"题目描述：比较两个版本号 version1 和 version2。 如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 如果version1 = version2返回 0。你可以假设版本字符串非空，并且只包含数字和 . 字符。(. 字符不代表小数点，而是用于分隔数字序列。) 例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。 你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。 示例：12输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;输出: -1 思路：其实就是先比较版本号中较大的版本号，再比较较小的版本号 1234567891011121314151617181920212223242526272829class Solution &#123; public int compareVersion(String version1, String version2) &#123; int i = 0; int j = 0; int num1 = 0; int num2 = 0; while (i &lt; version1.length() || j &lt; version2.length())&#123; while (i &lt; version1.length() &amp;&amp; version1.charAt(i) != &apos;.&apos;)&#123; num1 += num1 * 10 + version1.charAt(i) - &apos;0&apos;; i ++; &#125; i ++; while (j &lt; version2.length() &amp;&amp; version2.charAt(j) != &apos;.&apos;)&#123; num2 += num2 * 10 + version2.charAt(j) - &apos;0&apos;; j ++; &#125; j ++; if (num1 &gt; num2)&#123; return 1; &#125;else if (num1 &lt; num2)&#123; return -1; &#125;else &#123; num1 = 0; num2 = 0; &#125; &#125; return 0; &#125;&#125; 执行用时 :1 ms, 在所有 Java 提交中击败了99.85%的用户内存消耗 :34.8 MB, 在所有 Java 提交中击败了31.15%的用户","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"leetcode_medium","slug":"leetcode-medium","permalink":"http://yoursite.com/tags/leetcode-medium/"}]},{"title":"leetcode_114_二叉树展开为链表","date":"2019-08-31T07:18:13.000Z","path":"2019/08/31/2019-08-31_15_31/","text":"题目描述：给定一个二叉树，原地将它展开为链表。 示例：12345 1 / \\ 2 5 / \\ \\3 4 6 将其展开为： 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 思路：只需要每次把当前子树的最后一个节点传出来 123456789101112131415161718192021222324252627282930class Solution &#123; public void flatten(TreeNode root)&#123; if(root == null)&#123; return; &#125; generate(root); &#125; public TreeNode generate(TreeNode node)&#123; if(node.left == null &amp;&amp; node.right == null)&#123; return node; &#125; TreeNode backup_left = node.left; TreeNode backup_right = node.right; TreeNode last = null; node.left = null; if(backup_left != null)&#123; node.right = backup_left; last = generate(backup_left); if(backup_right != null)&#123; last.right = backup_right; &#125; &#125; if(backup_right != null)&#123; last = generate(backup_right); &#125; return last; &#125;&#125; 执行用时 :1 ms, 在所有 Java 提交中击败了99.94%的用户内存消耗 :35.9 MB, 在所有 Java 提交中击败了81.11%的用户","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"leetcode_medium","slug":"leetcode-medium","permalink":"http://yoursite.com/tags/leetcode-medium/"}]},{"title":"hexo的yilia主题 + github搭建博客","date":"2019-04-24T09:25:24.000Z","path":"2019/04/24/2019-04-24/","text":"Yilia是Litten设计的hexo主题，简约，典雅，它的中文名字叫伊丽雅，emmm…… 下面来介绍一下怎样使用这个主题搭建属于自己的博客 一、准备工作 安装NodeJs 需要配置环境变量 安装Git 注册github账号 配置SSH-key，用于远程连接和验证github 在github账号下面创建userName.github.io的仓库，userName是github用户名 二、安装hexo和使用 安装hexo：创建一个文件夹，在当前文件夹的git下npm install -g hexo 初始化hexo：hexo init 生成静态页面：hexo g 启动服务器：hexo s 服务器端口默认是4000，如果端口发生冲突，可以改端口值：hexo s -p5000 浏览器中访问：http://localhost:4000 三、","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]