[{"title":"leetcode_165_比较版本号","date":"2019-08-31T13:19:49.000Z","path":"2019/08/31/2019-08-31_21_19/","text":"题目描述：比较两个版本号 version1 和 version2。 如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 如果version1 = version2返回 0。你可以假设版本字符串非空，并且只包含数字和 . 字符。(. 字符不代表小数点，而是用于分隔数字序列。) 例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。 你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。 示例：12输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;输出: -1 思路：其实就是先比较版本号中较大的版本号，再比较较小的版本号 1234567891011121314151617181920212223242526272829class Solution &#123; public int compareVersion(String version1, String version2) &#123; int i = 0; int j = 0; int num1 = 0; int num2 = 0; while (i &lt; version1.length() || j &lt; version2.length())&#123; while (i &lt; version1.length() &amp;&amp; version1.charAt(i) != &apos;.&apos;)&#123; num1 += num1 * 10 + version1.charAt(i) - &apos;0&apos;; i ++; &#125; i ++; while (j &lt; version2.length() &amp;&amp; version2.charAt(j) != &apos;.&apos;)&#123; num2 += num2 * 10 + version2.charAt(j) - &apos;0&apos;; j ++; &#125; j ++; if (num1 &gt; num2)&#123; return 1; &#125;else if (num1 &lt; num2)&#123; return -1; &#125;else &#123; num1 = 0; num2 = 0; &#125; &#125; return 0; &#125;&#125; 执行用时 :1 ms, 在所有 Java 提交中击败了99.85%的用户内存消耗 :34.8 MB, 在所有 Java 提交中击败了31.15%的用户","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"leetcode_medium","slug":"leetcode-medium","permalink":"http://yoursite.com/tags/leetcode-medium/"}]},{"title":"leetcode_114_二叉树展开为链表","date":"2019-08-31T07:18:13.000Z","path":"2019/08/31/2019-08-31_15_31/","text":"题目描述：给定一个二叉树，原地将它展开为链表。 示例：12345 1 / \\ 2 5 / \\ \\3 4 6 将其展开为： 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 思路：只需要每次把当前子树的最后一个节点传出来 123456789101112131415161718192021222324252627282930class Solution &#123; public void flatten(TreeNode root)&#123; if(root == null)&#123; return; &#125; generate(root); &#125; public TreeNode generate(TreeNode node)&#123; if(node.left == null &amp;&amp; node.right == null)&#123; return node; &#125; TreeNode backup_left = node.left; TreeNode backup_right = node.right; TreeNode last = null; node.left = null; if(backup_left != null)&#123; node.right = backup_left; last = generate(backup_left); if(backup_right != null)&#123; last.right = backup_right; &#125; &#125; if(backup_right != null)&#123; last = generate(backup_right); &#125; return last; &#125;&#125; 执行用时 :1 ms, 在所有 Java 提交中击败了99.94%的用户内存消耗 :35.9 MB, 在所有 Java 提交中击败了81.11%的用户","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"leetcode_medium","slug":"leetcode-medium","permalink":"http://yoursite.com/tags/leetcode-medium/"}]},{"title":"hexo的yilia主题 + github搭建博客","date":"2019-04-24T09:25:24.000Z","path":"2019/04/24/2019-04-24/","text":"Yilia是Litten设计的hexo主题，简约，典雅，它的中文名字叫伊丽雅，emmm…… 下面来介绍一下怎样使用这个主题搭建属于自己的博客 一、准备工作 安装NodeJs 需要配置环境变量 安装Git 注册github账号 配置SSH-key，用于远程连接和验证github 在github账号下面创建userName.github.io的仓库，userName是github用户名 二、安装hexo和使用 安装hexo：创建一个文件夹，在当前文件夹的git下npm install -g hexo 初始化hexo：hexo init 生成静态页面：hexo g 启动服务器：hexo s 服务器端口默认是4000，如果端口发生冲突，可以改端口值：hexo s -p5000 浏览器中访问：http://localhost:4000 三、","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]